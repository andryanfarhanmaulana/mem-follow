{
  "readme_content": "# mem-follow: Cross-Chain Bridge Event Listener Simulation\n\nThis repository contains a Python script that simulates a critical component of a cross-chain bridge: an event listener node. This node is responsible for monitoring a bridge contract on a source blockchain (e.g., Ethereum), detecting deposit events, and triggering a corresponding token minting transaction on a destination blockchain (e.g., Polygon).\n\nThis script is designed as an architectural showcase, demonstrating key principles for building a reliable off-chain agent: modular design, persistent state management, resilience to network errors, and real-time interaction with blockchain networks.\n\n## Concept\n\nCross-chain bridges are essential for blockchain interoperability, allowing assets and data to move between otherwise siloed networks. A common design pattern is the \"lock-and-mint\" mechanism:\n\n1.  **Lock/Deposit:** A user deposits tokens (e.g., ERC-20) into a bridge contract on the source chain. The contract locks these tokens and emits an event (`TokensDeposited`) containing details like the recipient's address on the destination chain, the amount, and the destination chain ID.\n\n    ```solidity\n    // Example event in the source bridge contract\n    event TokensDeposited(\n        address indexed user,\n        address indexed recipient,\n        uint256 amount,\n        uint256 destinationChainId\n    );\n    ```\n\n2.  **Listen:** Off-chain nodes, often called validators or relayers, constantly monitor the source chain for these `TokensDeposited` events.\n\n3.  **Verify & Relay:** Upon detecting a valid event, a relayer node constructs, signs, and broadcasts a new transaction on the destination chain. This transaction calls a function (e.g., `mintBridgedTokens`) on the destination bridge contract.\n\n4.  **Mint/Release:** The destination bridge contract verifies the relayer's message and mints an equivalent amount of \"wrapped\" tokens to the specified recipient's address.\n\nThis script simulates the entire lifecycle of the **Listen** and **Verify & Relay** steps.\n\n## Code Architecture\n\nThe script is structured into several distinct classes, each with a single responsibility, promoting maintainability and testability.\n\n```\n+---------------------------+\n|          main.py          |\n| (Setup & Orchestration)   |\n+-------------+-------------+\n              |\n              | Starts\n              v\n+-------------+-----------------+\n|   BridgeContractListener      |  (Thread)\n|-------------------------------|\n| - Manages event filter        |\n| - Main listening loop         |\n| - Handles re-orgs, errors     |\n| - Coordinates other components|\n+-------------+-----------------+\n              |                   |                      |\n      (1. Event) v                  (2. Process) v             (3. Broadcast) v\n+--------------+----------+  +-----------------+  +----------------------+\n|   ChainConnector        |  |  EventProcessor |  | TransactionBroadcaster |\n| (Source & Destination)  |  |-----------------|  |----------------------|\n|-------------------------|  | - Validates     |  | - Builds transaction |\n| - Manages Web3 connection |  |   event data    |  | - Manages nonce      |\n| - Provides contract obj |  | - Prevents      |  | - Signs & Sends      |\n| - Retry logic           |  |   replays via   |  | - Waits for receipt  |\n+-------------------------+  |   StateDB       |  | - Gas estimation     |\n                           +--------+--------+  +----------------------+\n                                    |\n                               (Checks/Updates)\n                                    v\n                           +-----------------+\n                           |     StateDB     |\n                           |-----------------|\n                           | - Persists state|\n                           |   (JSON file)   |\n                           +-----------------+\n```\n\n-   **`ChainConnector`**: Manages the connection to a specific blockchain's RPC endpoint. It handles initial connection, status checks, and provides Web3 contract objects.\n-   **`StateDB`**: A simple persistent state manager. It tracks which event transaction hashes have already been processed to prevent duplicates (replay attacks). In this simulation, it uses a local JSON file.\n-   **`EventProcessor`**: The business logic core. It takes a raw event, validates its arguments (e.g., checks if it's for the correct destination chain), and transforms it into a structured payload ready for the destination chain transaction.\n-   **`TransactionBroadcaster`**: Responsible for the final step. It takes the processed data, builds the raw transaction (including nonce and gas), signs it with a private key, and broadcasts it to the destination chain. It includes a `SIMULATE_ONLY` mode.\n-   **`BridgeContractListener`**: The main orchestrator. Running in its own thread, it sets up an event filter on the source contract, polls for new events in a continuous loop, and passes them through the `EventProcessor` and `TransactionBroadcaster`. It also includes logic for handling block re-organizations and connection errors.\n\n    ```python\n    # Simplified snippet from the listener's main loop\n    def run(self):\n        while not self._stop_event.is_set():\n            try:\n                for event in self.event_filter.get_new_entries():\n                    # ... logic to handle confirmation delays ...\n                    self.process_event(event)\n            except Exception as e:\n                logger.error(f\"Error polling for events: {e}\")\n            time.sleep(POLL_INTERVAL)\n    ```\n\n## How it Works\n\n1.  **Initialization**: The `main` function reads configuration from a `.env` file, including RPC URLs, contract addresses, and a private key for the relayer wallet.\n2.  **Connection**: It establishes connections to both the source and destination chains using `ChainConnector` instances.\n3.  **State Loading**: `StateDB` loads the list of previously processed transaction hashes from `processed_events_db.json`.\n4.  **Listener Start**: The `BridgeContractListener` is instantiated and started in a separate thread.\n5.  **Polling Loop**: The listener thread creates an event filter and enters a loop where it periodically polls for new `TokensDeposited` events.\n6.  **Confirmation Delay**: To protect against blockchain re-organizations, the script waits for a configurable number of blocks (`confirmation_blocks`) to pass before processing an event.\n7.  **Event Processing**: Once an event is confirmed (after waiting for the configured `confirmation_blocks`), the `EventProcessor` is invoked.\n    -   It first checks the `StateDB` to ensure the event has not been processed before.\n    -   It validates the event's data.\n    -   If valid, it prepares a dictionary with the necessary data for the minting transaction.\n8.  **Transaction Broadcasting**: The prepared data is passed to the `TransactionBroadcaster`.\n    -   It fetches the current nonce for the relayer account.\n    -   It builds and signs the `mintBridgedTokens` transaction.\n    -   If `SIMULATE_ONLY` is `False`, it sends the transaction to the destination chain and waits for the receipt.\n9.  **State Update**: Upon successful broadcast, the `StateDB` is updated with the source event's transaction hash, preventing it from being processed again.\n10. **Graceful Shutdown**: The script listens for a `KeyboardInterrupt` (Ctrl+C) to shut down the listener thread cleanly.\n\n## Prerequisites\n\n- Python 3.8 or higher.\n- Access to RPC endpoints for a source and a destination blockchain (e.g., via [Infura](https://infura.io) or [Alchemy](https://www.alchemy.com/)).\n\n## Usage\n\n1.  **Clone the repository:**\n    ```bash\n    git clone https://github.com/your-github-username/mem-follow.git\n    cd mem-follow\n    ```\n\n2.  **Create a virtual environment and install dependencies:**\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # On Windows, use `venv\\Scripts\\activate`\n    pip install --upgrade pip\n    pip install -r requirements.txt\n    ```\n\n3.  **Set up your environment variables:**\n    Create a `.env` file from the example. This file will store your secret keys and RPC endpoints.\n    ```bash\n    cp .env.example .env\n    ```\n    Now, populate `.env` with your own data.\n\n    **Example `.env` file:**\n    ```env\n    # --- SOURCE CHAIN (e.g., Ethereum Sepolia Testnet) ---\n    SOURCE_CHAIN_RPC=\"https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID\"\n    # Address of the source chain bridge contract to listen to\n    SOURCE_BRIDGE_CONTRACT=\"0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B\"\n\n    # --- DESTINATION CHAIN (e.g., Polygon Mumbai Testnet) ---\n    DEST_CHAIN_RPC=\"https://polygon-mumbai.infura.io/v3/YOUR_INFURA_PROJECT_ID\"\n    DEST_CHAIN_ID=80001\n    # Address of the destination chain contract that mints bridged tokens\n    DEST_MINT_CONTRACT=\"0x4B29A516006a8A3951295a4deaB5155a6a25691C\"\n\n    # --- RELAYER WALLET ---\n    # IMPORTANT: Use a dedicated burner wallet funded only with enough ETH/MATIC for gas fees.\n    # NEVER USE A WALLET WITH SIGNIFICANT ASSETS for development or production relaying.\n    SIGNER_PRIVATE_KEY=\"0xyour_private_key_here\"\n\n    # --- SCRIPT BEHAVIOR ---\n    # Set to 'False' to actually broadcast transactions. Default is 'True'.\n    SIMULATE_ONLY=\"True\"\n    ```\n\n4.  **Run the script:**\n    ```bash\n    python main.py\n    ```\n\n5.  **Observe the output:**\n    The script will start logging its status. If a `TokensDeposited` event occurs on the source contract that matches the criteria, you will see logs detailing the processing and (simulated) broadcasting steps.\n\n    ```\n    2023-10-27 15:30:00 - INFO - [MainThread] - Successfully connected to SourceChain at https://sepolia.infura.io/v3/...\n    2023-10-27 15:30:01 - INFO - [MainThread] - Successfully connected to DestinationChain at https://polygon-mumbai.infura.io/v3/...\n    2023-10-27 15:30:01 - INFO - [BridgeListenerThread] - Starting to listen for 'TokensDeposited' events on 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B...\n    ...\n    2023-10-27 15:32:15 - INFO - [BridgeListenerThread] - Processing new event from tx: 0x123abc...def456\n    2023-10-27 15:32:15 - INFO - [BridgeListenerThread] - Prepared transaction for destination chain: {'recipient': '0x...', 'amount': 100000000, ...}\n    2023-10-27 15:32:15 - INFO - [BridgeListenerThread] - Broadcasting tx for source hash 0x123abc...def456...\n    2023-10-27 15:32:16 - WARNING - [BridgeListenerThread] - [SIMULATION MODE] Would broadcast transaction. Hash: 0x789ghi...jkl123\n    2023-10-27 15:32:16 - INFO - [BridgeListenerThread] - Marked transaction 0x123abc...def456 as processed.\n    ```"
}